<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>ATAforecasting: Automatic Time Series Analysis and Forecasting using Ata Method with Box-Cox Power Transformations Family and Seasonal Decomposition Techniques — ATAM • fable.ata</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="ATAforecasting: Automatic Time Series Analysis and Forecasting using Ata Method with Box-Cox Power Transformations Family and Seasonal Decomposition Techniques — ATAM" />
<meta property="og:description" content="Returns ATA(p,q,phi) applied to X.
The Ata method based on the modified simple exponential smoothing as described in Yapar, G. (2016) &amp;lt;doi:10.15672/HJMS.201614320580&amp;gt; ,
Yapar G., Capar, S., Selamlar, H. T., Yavuz, I. (2017) &amp;lt;doi:10.15672/HJMS.2017.493&amp;gt; and Yapar G., Selamlar, H. T., Capar, S., Yavuz, I. (2019)
&amp;lt;doi:10.15672/hujms.461032&amp;gt; is a new univariate time series forecasting method which provides innovative solutions to issues faced during
the initialization and optimization stages of existing methods.
Forecasting performance of the Ata method is superior to existing methods both in terms of easy implementation and accurate forecasting.
It can be applied to non-seasonal or seasonal time series which can be decomposed into four components (remainder, level, trend and seasonal).
This methodology performed well on the M3 and M4-competition data.
Returns ATA(p,q,phi) applied to X." />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">fable.ata</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.0.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/alsabtay/fable.ata/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>ATAforecasting: Automatic Time Series Analysis and Forecasting using Ata Method with Box-Cox Power Transformations Family and Seasonal Decomposition Techniques</h1>
    <small class="dont-index">Source: <a href='https://github.com/alsabtay/fable.ata/blob/master/R/fable_ata.R'><code>R/fable_ata.R</code></a></small>
    <div class="hidden name"><code>ATAM.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Returns ATA(p,q,phi) applied to <code>X</code>.
The Ata method based on the modified simple exponential smoothing as described in Yapar, G. (2016) &lt;doi:10.15672/HJMS.201614320580&gt; ,
Yapar G., Capar, S., Selamlar, H. T., Yavuz, I. (2017) &lt;doi:10.15672/HJMS.2017.493&gt; and Yapar G., Selamlar, H. T., Capar, S., Yavuz, I. (2019)
&lt;doi:10.15672/hujms.461032&gt; is a new univariate time series forecasting method which provides innovative solutions to issues faced during
the initialization and optimization stages of existing methods.
Forecasting performance of the Ata method is superior to existing methods both in terms of easy implementation and accurate forecasting.
It can be applied to non-seasonal or seasonal time series which can be decomposed into four components (remainder, level, trend and seasonal).
This methodology performed well on the M3 and M4-competition data.
Returns ATA(p,q,phi) applied to <code>X</code>.</p>
    </div>

    <pre class="usage"><span class='fu'>ATAM</span><span class='op'>(</span><span class='va'>formula</span>, <span class='va'>...</span><span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>formula</th>
      <td><p>Model specification (see "Specials" section).</p></td>
    </tr>
    <tr>
      <th>...</th>
      <td><p>Other arguments</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>A model specification.</p>
    <h2 class="hasAnchor" id="specials"><a class="anchor" href="#specials"></a>Specials</h2>

    


<p>The _specials_ define the methods and parameters for the components (level, trend, seasonality, accuracy, transform, holdout) of an ATA method.</p>
<p>There are a couple of limitations to note about ATA method:</p>
<p>- It supports only additive error term.
- It does not support exogenous regressors.
- It does not support missing values. You can complete missing values in the data with imputed values (e.g. with [tsibble::fill_gaps()], [tidyr::fill()], or by fitting a different model type and then calling [fabletools::interpolate()]) before fitting the model.</p>
<h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>level</h3>
<p>The `level` special is used to specify the form of the level term.</p><pre>
<span class='fu'>level</span><span class='op'>(</span>parP <span class='op'>=</span> <span class='cn'>NULL</span>, level_fixed <span class='op'>=</span> <span class='cn'>TRUE</span>, initial_level <span class='op'>=</span> <span class='cn'>FALSE</span><span class='op'>)</span>
</pre>

<table class='table'>
<tr><td>`parP`</td><td>The value of the smoothing parameter for the level. If `p = 0`, the level will not change over time. Conversely, if `p = 1` the level will update similarly to a random walk process. If NULL or "opt", it is estimated. <code>p</code> has all integer values from 1 to <code><a href='https://rdrr.io/r/base/length.html'>length(data)</a></code>.</td></tr>
<tr><td>`level_fixed`</td><td>If TRUE, "pStarQ"  --&gt; First, fits ATA(p,0) where p = p* is optimized for q=0. Then, fits ATA(p*,q) where q is optimized for p = p*.</td></tr>
<tr><td>`initial_level`</td><td>If NULL, FALSE is default. If FALSE, ATA Method calculates the pth observation in <code>data</code> for level. If TRUE, ATA Method calculates average of first p value in <code>data</code>for level.</td></tr>
</table>



<h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>trend</h3>
<p>The `trend` special is used to specify the form of the trend term and associated parameters.</p><pre>
<span class='fu'>trend</span><span class='op'>(</span>type <span class='op'>=</span> <span class='st'>"A"</span>, parQ <span class='op'>=</span> <span class='cn'>NULL</span>, initial_trend <span class='op'>=</span> <span class='cn'>FALSE</span>, opt_trend <span class='op'>=</span> <span class='st'>"none"</span>,
       parPHI <span class='op'>=</span> <span class='cn'>NULL</span>, parPHI_range <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='fl'>0.8</span>, <span class='fl'>1.0</span><span class='op'>)</span>, parPHI_increment <span class='op'>=</span> <span class='fl'>0.01</span>,
       uroot_test <span class='op'>=</span> <span class='st'>"adf"</span>, uroot_alpha <span class='op'>=</span> <span class='fl'>0.05</span>, uroot_type <span class='op'>=</span> <span class='st'>"level"</span><span class='op'>)</span>
</pre>

<table class='table'>
<tr><td>`type`</td><td>The form of the trend term: either none ("N"), additive ("A"), multiplicative ("M") or damped variants ("Ad", "Md").</td></tr>
<tr><td>`parQ`</td><td>The value of the smoothing parameter for the slope. If `Q = 0`, the slope will not change over time. Conversely, if `Q = 1` the slope will have no memory of past slopes.</td></tr>
<tr><td>`parPHI`</td><td>The value of the dampening parameter for the slope. If `phi = 0`, the slope will be dampened immediately (no slope). Conversely, if `phi = 1` the slope will not be dampened.</td></tr>
<tr><td>`parPHI_range`</td><td>If `phi=NULL`, `phi_range` provides bounds for the optimised value of `phi`.</td></tr>
<tr><td>`parPHI_increment`</td><td>If `phi=NULL`, `parPHI_increment` provides increment step for searching `phi`. If NULL, `parPHI_increment` will be determined as the value that allows the `parPHI_range` to be divided into 20 equal parts.</td></tr>
<tr><td>`initial_trend`</td><td>If NULL, FALSE is default. If FALSE, ATA Method calculates the qth observation in <code>X(T)-X(T-1)</code> for trend. If TRUE, ATA Method calculates average of first q value in <code>X(T)-X(T-1)</code> for trend.</td></tr>
<tr><td>`trend_opt`</td><td>Default is `none`. If `fixed` is set, "pBullet" --&gt; Fits ATA(p,1) where p = p* is optimized for q = 1. If `search` is set "qBullet" --&gt; Fits ATA(p,q) where p = p* is optimized for q = q* (q &gt; 0). Then, fits ATA(p*,q) where q is optimized for p = p*.</td></tr>
<tr><td>`uroot_test`</td><td>Type of unit root test before all type seasonality test. Possible values are "adf", "pp" and "kpss".</td></tr>
<tr><td>`uroot_alpha`</td><td>Significant level of the unit root test, possible values range from 0.01 to 0.1.</td></tr>
<tr><td>`uroot_type`</td><td>Specification of the deterministic component in the regression for unit root test. Possible values are "level" and "trend".</td></tr>
</table>



<h3 class='hasAnchor' id='arguments'><a class='anchor' href='#arguments'></a>season</h3>
<p>The `season` special is used to specify the form of the seasonal term and associated parameters. To specify a nonseasonal model you would include `season(method = "N")`.</p><pre>
<span class='fu'>season</span><span class='op'>(</span>type <span class='op'>=</span> <span class='st'>"A"</span>, test <span class='op'>=</span> <span class='cn'>TRUE</span>, period <span class='op'>=</span> <span class='cn'>NULL</span>, method <span class='op'>=</span> <span class='st'>"decomp"</span>,
       suroot_test <span class='op'>=</span> <span class='st'>"correlogram"</span>, suroot_tcrit <span class='op'>=</span> <span class='fl'>1.28</span>, suroot_uroot <span class='op'>=</span> <span class='cn'>TRUE</span>, suroot_m <span class='op'>=</span> <span class='cn'>NULL</span><span class='op'>)</span>
</pre>
<table class='table'>
<tr><td>`type`</td><td>The form of the seasonal term: either none ("N"), additive ("A") or multiplicative ("M").</td></tr>
<tr><td>`test`</td><td>Testing for stationary and seasonality. If TRUE, the method firstly uses <code>test="adf"</code>, Augmented Dickey-Fuller, unit-root test then the test returns the least number of differences required to pass the test at level <code>alpha</code>. After the unit-root test, seasonal test applies on the stationary <code>data</code>.</td></tr>
<tr><td>`period`</td><td>The periodic nature of the seasonality. This can be a number indicating the number of observations in each seasonal period (for example, annual seasonality would be "1").</td></tr>
<tr><td>`method`</td><td>A string identifying method for seasonal decomposition. If NULL, "decomp" method is default. Possible values are c("none", "decomp", "stl", "stlplus", "tbats", "stR") phrases of methods denote.</td></tr>
<tr><td>`suroot_test`</td><td>Type of seasonal unit root test to use. Possible values are "correlogram", "seas", "hegy", "ch" and "ocsb".</td></tr>
<tr><td>`suroot_tcrit`</td><td>t-value for autocorrelogram.</td></tr>
<tr><td>`suroot_uroot`</td><td>If TRUE, unit root test for stationary before seasonal unit root test is allowed.</td></tr>
<tr><td>`suroot.m`</td><td>Deprecated. Length of seasonal period: frequency of data for nsdiffs.</td></tr>
</table>




  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Ali Sabri Taylan, Hanife Taylan Selamlar, Guckan Yapar.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


